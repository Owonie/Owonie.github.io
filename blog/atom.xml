<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://owonie.github.io/blog</id>
    <title>리버스 디벨로핑 Blog</title>
    <updated>2024-11-15T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://owonie.github.io/blog"/>
    <subtitle>리버스 디벨로핑 Blog</subtitle>
    <icon>https://owonie.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[렌더링의 멱등성에 대한 고찰]]></title>
        <id>https://owonie.github.io/blog/20241115</id>
        <link href="https://owonie.github.io/blog/20241115"/>
        <updated>2024-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[주: 해당 글은 프론트엔드 개발에서 사용하는 컴포넌트 개념을 기준으로 작성됩니다.]]></summary>
        <content type="html"><![CDATA[<p>주: 해당 글은 프론트엔드 개발에서 사용하는 컴포넌트 개념을 기준으로 작성됩니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="지난-화-줄거리">지난 화 줄거리<a href="https://owonie.github.io/blog/20241115#%EC%A7%80%EB%82%9C-%ED%99%94-%EC%A4%84%EA%B1%B0%EB%A6%AC" class="hash-link" aria-label="지난 화 줄거리에 대한 직접 링크" title="지난 화 줄거리에 대한 직접 링크">​</a></h3>
<p>컴포넌트를 정확하게 두 요소로 분리해주세요.
<code>A + B = "컴포넌트"</code>
많은 키워드가 나오기 시작했다...
(궁금하면 이전 글을 참고하시오)</p>
<p>항상 꼬리가 꼬리를 무는 기술 얘기는 모두의(?) 기분을 좋게 만든다.
컴포넌트를 논할 때 UI(화면)와 State(상태) 라는 키워드가 계속 등장했는데,
필자는 상태관리와 컴포넌트 간의 어떤 연관관계가 있을지 문득 궁금해졌다.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">도원:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">결국 컴포넌트는 "상태" 라는 키워드를 벗어날 수 없는 것 같아요.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">화면을 그려주는 코드 + 화면 데이터를 처리하는 코드 (aka 비즈니스 로직)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">보편적으로 이 두가지 요소로 컴포넌트를 바라볼 수 있는 것 같네요.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">그렇다면 상태관리를 잘 한다는 건 어떤 의미일까요?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ex: "화면을 잘 그려주고, 화면에 보여줄 데이터를 잘 처리한다".</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>수많은 JD에서 "능숙한 상태관리 경험이 있으신 분"이라는 본적이 있다. 잘하는 프론트엔드 개발자에게
상태관리를 잘하는 건 너무 당연한 일이기 때문이다. 그렇다면 상태관리라는 개념을 분석해볼 가치가 있다고 생각했다.</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1차토론---보성--도원">1차토론 - 보성 &amp; 도원<a href="https://owonie.github.io/blog/20241115#1%EC%B0%A8%ED%86%A0%EB%A1%A0---%EB%B3%B4%EC%84%B1--%EB%8F%84%EC%9B%90" class="hash-link" aria-label="1차토론 - 보성 &amp; 도원에 대한 직접 링크" title="1차토론 - 보성 &amp; 도원에 대한 직접 링크">​</a></h2>
<p>보성:
상태 관리를 잘한다라... 상태의 흐름이 예측 가능하면 좋은 상태 관리 아닐까요?
전역 상태 대신에 프롭스 드릴링 같은 단방향 구조가 추적하기 쉽고 예측하기 쉽듯이,
어떤 상태의 이전과 다음의 상태들이 예측 가능한 구조들이라면 괜찮은 상태가 아닐까.</p>
<p>도원: "좋은 상태관리 흐름/구조를 만들 수 있다"로 이해하면 될까요?</p>
<p>보성: 네 이해하신바가 정확합니다.</p>
<p>도원:
그렇다면 컴포넌트 입장에서 "상태관리를 잘한다"는 어떤 개념으로 다가가면 될까요,
바꿔서 질문하자면 컴포넌트를 사용하는데, 왜 상태관리를 잘해야할까요? (발제1)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="왜-상태관리를-잘해야하는가">왜 상태관리를 잘해야하는가?<a href="https://owonie.github.io/blog/20241115#%EC%99%9C-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9E%98%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80" class="hash-link" aria-label="왜 상태관리를 잘해야하는가?에 대한 직접 링크" title="왜 상태관리를 잘해야하는가?에 대한 직접 링크">​</a></h3>
<p>보성:
컴포넌트가 상태에 강하게 의존하고 있으니까 아닐까요, 바꿔 말하자면 컴포넌트를 관리하는 상태가
예측 불가능하면 예측 불가능한 컴포넌트가 되어버리는거죠.</p>
<p>도원: 예측 불가능한 컴포넌트는 버려질까요?</p>
<p>보성: 예측 불가능한 컴포넌트를 사용하는 서비스는 버려질 것 같아요.</p>
<p>도원:
예측 불가능하게 구현된 컴포넌트는 애초에 "컴포넌트" 로서의 가치가 떨어진다는 얘기군요.
프로젝트 리소스 로서 가치가 떨어지니깐, 그럼 상태관리를 해준다는건, "컴포넌트들을 관리하는 것"과
동일 시 할 수 있겠어요. 물이 고이지 않고, 공기를 순환시키듯이.</p>
<p>보성: 어렵네요 두 가지를 분리하는게</p>
<p>도원: 뭔가 애매한 어딘가에 걸쳐있는 느낌이에요.</p>
<p>보성: "하나의 컴퍼넌트의 지역적인 상태인가, 컴퍼넌트끼리 전달되는 shared한 상태인가" 가 중요할 것 같기도하네요.</p>
<p>깜짝 등장한 준호: 상태에 벗어날수 있죠! 헤드리스! 일부러 벗어나게 의도한거지만, 프롭스로 받는것도 상태라고 취급하면…종속된다고 볼수있지만.</p>
<p>도원: 상태라는 개념에서 파생된 내용이기에 벗어나기 어렵다라고 표현해봤어요. "상태 안떠오르기" 는 불가능 하니깐요.</p>
<p>다시 사라지는 준호: 상태 vs 안상태...</p>
<p>도원: (보성의 local/shared 글을 멘션하며) local / global / lexical 은 뭔가 결국 "상태" 라는 속성이 컴포넌트에 존재하고 있다는거잖아요?</p>
<div class="language-aiignore codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aiignore codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Component {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	state: local / global / lexical ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>도원: 속성 값 관리를 누구에게 위임할거냐, 재무를 개인 회계사에게 맡길거냐, 직접 할거냐, 요런 느낌.
(만지작 대며 코드를 수정한다)</p>
<div class="language-aiignore codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aiignore codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Component {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	UI : UI(state) + stateless UI</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	상태: local / lexical / global</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>도원: 결국 그건가. <code>UI(state) = Component</code></p>
<p>보성: 그렇죠, 함수로도 표현할 수 있지만, 그림으로 표현하면 말씀하신것처럼 다양한 범위로 관리되는 상태를 가지고 UI를 그려내는 그런 모습이 보이네요.</p>
<p>혼잣말을 하는 도원: 프론트엔드의 역할이 단순히 데이터를 보여주는게 아니라 유저의 context(맥락 또는 행동)을 추적하고, 지속적으로 서비스를 제공하는 행위를...
말하다 보니까 뭔가 복잡하네요.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="렌더링에-멱등성이-있다">렌더링에 멱등성이 있다?<a href="https://owonie.github.io/blog/20241115#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%B4-%EC%9E%88%EB%8B%A4" class="hash-link" aria-label="렌더링에 멱등성이 있다?에 대한 직접 링크" title="렌더링에 멱등성이 있다?에 대�한 직접 링크">​</a></h3>
<p>도원: 리렌더링엔 멱등성이 있네요. http 통신처럼, 렌더링 마다 멱등성이 파괴되는걸 목격하게 될거고 클래스 컴포넌트가 도태되는것도 이해가 되네요.</p>
<p>보성: 정확하게 따지면 멱등성이 있는데, 그 컴퍼넌트가 상태를 바꾸는 이펙트를 호출하는 컴퍼넌트라면 멱등성이라고 하기엔 또 모호해지는, view에 보일때마다 조회수가 1씩 올라가는 컴퍼넌트라면…</p>
<p>도원: 그럼 그 컴포넌트는 컴포넌트가 아니라 모델이나 뭐 어디쯤 되는 친구 아닐까요.</p>
<p>도원: 이건 어때요, 렌더링과 이펙트를 명확히 분리하지 않아 발생하는 멱등성 상실.</p>
<p>보성: 어렵네요 이해가.. 그런데 제가 조금 잘못되게 표현한 것 같기도해요. 결국 렌더링은… 음 아니다</p>
<p>도원: 편하게 얘기해주세요.</p>
<p>보성: 리렌더링은 멱등성을 띄는게 맞는지 아닌지가 가장 관건이네요. 애초에 표현이 맞는지가 헷갈려요. 렌더링을 멱등성을 가진다 가 아니라 리렌더링이니까 더 고민하게되네요.</p>
<p>도원: 렌더링으로 시정하겠습니다. 원래 궁금했던 것도 "렌더링의 멱등성"이라.</p>
<p>보성: 상태가 아니라 시간에 의존하는 컴포넌트라면? new Date를 toLocale 같은 메서드로 화면에 보여주는 값이 있다면?
그런데 다시 렌더링으로 돌아오게 된다면 안에서 의존하는 값 (useQuery의 data등도 결국 state일테니) 과 props로 내려주는 값이 똑같다면
똑같이 렌더되겠지요? 근데 상태는 완전히 똑같은 값을 받았는데 내 부모 컨테이너의 넓이가 커지거나 작아지거나해서 리페인팅 될때 작아지거나 커졌다면?
그것도 멱등성이라고 봐야하는가?</p>
<p>도원: 컴포넌트 끼리 서로 렌더링 기능을 의존하고 있는 상황을 말씀하시는 거군요</p>
<p>보성: 그렇죠, 상태에만 의존한다고 생각했는데, 심지어 상태가 똑같더라도 렌더링은 다르게 될 수 있네요.
nth-child같은 요소에 의해서 다르게 칠해질 수 도 있고 부모 넓이에 영향을 받을 수도 있고.</p>
<p>도원: 렌더링 함수가 영향을 받는걸까요, 아니면 컴포넌트의 state(nth 요소? 부모의 크기?) 가 바뀌는걸까요?</p>
<p>보성: state가 바뀌는 것은 아닌 것 같습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="img_1png"><img decoding="async" loading="lazy" alt="img_1.png" src="https://owonie.github.io/assets/images/img_1-475b0df6d69284edf0ca118b3081688c.png" width="724" height="250" class="img_ev3q"><a href="https://owonie.github.io/blog/20241115#img_1png" class="hash-link" aria-label="img_1png에 대한 직접 링크" title="img_1png에 대한 직접 링크">​</a></h2>
<p>작성 중입니다.</p>]]></content>
        <author>
            <name>Dowon Choi</name>
            <uri>https://github.com/Owonie</uri>
        </author>
        <author>
            <name>Bosung Baek</name>
            <uri>https://github.com/BO-LIKE-CHICKEN</uri>
        </author>
        <author>
            <name>Jooeun Kang</name>
            <uri>https://github.com/joogle-ay</uri>
        </author>
        <category label="심적표상" term="심적표상"/>
        <category label="컴포넌트" term="컴포넌트"/>
        <category label="렌더링" term="렌더링"/>
        <category label="상태관리" term="상태관리"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[A + B = 컴포넌트]]></title>
        <id>https://owonie.github.io/blog/20241114</id>
        <link href="https://owonie.github.io/blog/20241114"/>
        <updated>2024-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[컴포넌트를 정확하게 두 요소로 분리해주세요.]]></summary>
        <content type="html"><![CDATA[<p>컴포넌트를 정확하게 두 요소로 분리해주세요.
A + B = "컴포넌트"
컴포넌트가 모듈의 컴포넌트인지 UI 컴포넌트인지는 미정이에요.</p>
<p>일단 저먼저 : "UI 컴포넌트" + "모듈 컴포넌트" = "컴포넌트"
편하게 뇌안거치고 지르셔도 됩니다. 다만 상대방의 분해에 대해 의견이 있다면 얘기 자유롭게 가능.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="분해의-산물">분해의 산물<a href="https://owonie.github.io/blog/20241114#%EB%B6%84%ED%95%B4%EC%9D%98-%EC%82%B0%EB%AC%BC" class="hash-link" aria-label="분해의 산물에 대한 직접 링크" title="분해의 산물에 대한 직접 링크">​</a></h3>
<ul>
<li>"UI 컴포넌트" + "모듈 컴포넌트" = 컴포넌트</li>
<li>"hooks" + "UI" = 컴포넌트 -&gt;  "화면" + "비즈니스로직" = 컴포넌트</li>
<li>"JSX 태그" + "State / Statement" = 컴포넌트</li>
<li>"함수형 컴포넌트" + "클래스 컴포넌트" = 컴포넌트</li>
<li>"UI컴포넌트" + "이펙트" = 컴포넌트</li>
<li>"컴포넌트" + "컴포넌트" = 컴포넌트</li>
<li>"모듈" + "모듈" = 컴포넌트</li>
<li>"요소" + "구조" = 컴포넌트</li>
<li>"모듈" + "관점지향" = 컴포넌트</li>
<li>"컴포" + "넌트" = 컴포넌트 (Junho stared this)</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="junhos-comment">Junho's Comment<a href="https://owonie.github.io/blog/20241114#junhos-comment" class="hash-link" aria-label="Junho's Comment에 대한 직접 링크" title="Junho's Comment에 대한 직접 링크">​</a></h3>
<p><code>"JSX 태그" + "State / Statement" = 컴포넌트</code></p>
<p>사실 컴포넌트는, 단일 컴포넌트 자체로 하나의 페이지라고 생각 할 수 있을 것 같아요
A + B 라고 했지만 만약 A + B + C 라고 하면 하나의 페이지를 구성하기 위해 html + css + js 가 필요한 것 처럼
컴포넌트 또한 html을 담당하는 Return 의 tag 들과 같이 처리되는 css들 그리고 js를 담당하는 hooks로 취급되는 비즈니스 로직들이 될 것 같습니다.</p>
<p>조금 더 추가하자면, html 의 경우 기본 tag들도 있지만 다른 컴포넌트들도 html이라고 포함할 수 있을 것 같고요.
css의 경우에는 컴포넌트 외부에서 import 받을 수도 있지만 기본적으로는 컴포넌트에 종속된다고 볼 수 있습니다. 이는 생략도 가능하죠 css 없는 페이지가 존재하는 것처럼요</p>
<p>js가 담당하는 부분의 경우, 리액트 컴포넌트에서는 custom hooks 로 분리될 수 있죠 무조건 분리되야하진 않아서 hooks 라고 표현하기 보다는 그냥 비즈니스 로직이라고 하는게 맞을 수도있을 것 같습니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bosungs-comment">Bosung's Comment<a href="https://owonie.github.io/blog/20241114#bosungs-comment" class="hash-link" aria-label="Bosung's Comment에 대한 직접 링크" title="Bosung's Comment에 대한 직접 링크">​</a></h3>
<p><code>"hooks" + "UI" = 컴포넌트 -&gt;  "화면" + "비즈니스로직" = 컴포넌트</code></p>
<p>리액트의 컴포넌트로 생각하고
-&gt; JSX 태그 + JSX 태그에 주입하는 값 혹은 상태</p>
<p>상태가 변경될 때마다 새로운 UI 스냅샷을 찍어내므로
상태를 받는 JSX태그와 값으로만 이루어져 있고 나머지는 이 스냅샷을 위한 것이다?</p>
<p>state로 가야할지 아니면 문(statement)로 가야할지는 고민이네요. state는 아시는 것처럼 state가 변하는 것이 컴퍼넌트를 다시 그리는 조건 중에 하나이고, 문(statement)은 계속해서 값이 바뀌고 있어도 리렌더링이 일어나지 않을 가능성이 있기 때문에, 어떤게 더 적절할지 고민입니다.</p>]]></content>
        <author>
            <name>Dowon Choi</name>
            <uri>https://github.com/Owonie</uri>
        </author>
        <author>
            <name>Bosung Baek</name>
            <uri>https://github.com/BO-LIKE-CHICKEN</uri>
        </author>
        <author>
            <name>Junho Yun</name>
            <uri>https://github.com/yunjunhojj</uri>
        </author>
        <category label="심적표상" term="심적표상"/>
        <category label="토취반" term="토취반"/>
        <category label="컴포넌트" term="컴포넌트"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[JD를 통한 커리어 영점조정]]></title>
        <id>https://owonie.github.io/blog/20241113</id>
        <link href="https://owonie.github.io/blog/20241113"/>
        <updated>2024-11-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[관심있는 JD를 모두 모아 gpt에게 핵심 키워드를 추출해달라 해봤다.]]></summary>
        <content type="html"><![CDATA[<p>관심있는 JD를 모두 모아 gpt에게 핵심 키워드를 추출해달라 해봤다.</p>
<p>커리어 방향성을 JD 에서 참조하는 것도 좋은 방법이라 생각한다.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="a-프론트엔드-핵심-기술">A. 프론트엔드 핵심 기술<a href="https://owonie.github.io/blog/20241113#a-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%95%B5%EC%8B%AC-%EA%B8%B0%EC%88%A0" class="hash-link" aria-label="A. 프론트엔드 핵심 기술에 대한 직접 링크" title="A. 프론트엔드 핵심 기술에 대한 직접 링크">​</a></h4>
<p>•	HTML/CSS: HTML과 CSS에 대한 깊은 이해
•	JavaScript 및 TypeScript: JavaScript와 TypeScript의 심화 지식
•	정적 타입 분석 도구: TypeScript, ReScript, Flow
•	React: React.js의 전반적인 프로젝트 경험
•	Context API, React Router, React Query 등 React 에코시스템 전반에 걸친 지식이 요구됨
•	스타일링: Stitches와 Emotion 같은 CSS-in-JS 도구 활용</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="b-상태-관리와-비즈니스-로직">B. 상태 관리와 비즈니스 로직<a href="https://owonie.github.io/blog/20241113#b-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EC%99%80-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EB%A1%9C%EC%A7%81" class="hash-link" aria-label="B. 상태 관리와 비즈니스 로직에 대한 직접 링크" title="B. 상태 관리와 비즈니스 로직에 대한 직접 링크">​</a></h4>
<p>•	상태 관리:
•	Redux, Context API, Zustand, Recoil, Tanstack-Query (React Query), SWR, GraphQL Relay
•	복잡한 상태 관리 및 서버 상태 관리의 필요성에 맞춰 여러 상태 관리 라이브러리에 대한 비교, 응용 및 최적화 경험
•	GraphQL과 클라이언트 관리:
•	GraphQL 클라이언트 및 Relay 기반의 데이터 페칭 최적화 경험
•	Apollo, urql, Relay 등의 GraphQL 클라이언트 경험</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="c-개발-경험dx-및-생산성-향상">C. 개발 경험(DX) 및 생산성 향상<a href="https://owonie.github.io/blog/20241113#c-%EA%B0%9C%EB%B0%9C-%EA%B2%BD%ED%97%98dx-%EB%B0%8F-%EC%83%9D%EC%82%B0%EC%84%B1-%ED%96%A5%EC%83%81" class="hash-link" aria-label="C. 개발 경험(DX) 및 생산성 향상에 대한 직접 링크" title="C. 개발 경험(DX) 및 생산성 향상에 대한 직접 링크">​</a></h4>
<p>•	자동화 및 CI/CD:
•	GitHub Actions, CircleCI를 통한 CI/CD 파이프라인 구성과 자동화
•	라이브러리, 코드 스플리팅 등 생산성 향상을 위한 도구들 (e.g., Webpack, Esbuild, Babel, SWC)
•	개발 환경 및 생산성 도구:
•	Yarn Berry, PNPM 등 패키지 관리 도구
•	다양한 빌드 도구 및 모듈 번들러 (Webpack, SWC 등)</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="d-풀스택-및-백엔드-연계-경험">D. 풀스택 및 백엔드 연계 경험<a href="https://owonie.github.io/blog/20241113#d-%ED%92%80%EC%8A%A4%ED%83%9D-%EB%B0%8F-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%97%B0%EA%B3%84-%EA%B2%BD%ED%97%98" class="hash-link" aria-label="D. 풀스택 및 백엔드 연계 경험에 대한 직접 링크" title="D. 풀스택 및 백엔드 연계 경험에 대한 직접 링크">​</a></h4>
<p>•	서버 및 API 통신:
•	SSR과 CSR에 대한 이해와 실전 적용 경험
•	Full-stack 관점에서의 서버와 클라이언트 통합, 데이터 페칭 최적화
•	백엔드 연계:
•	Kotlin/Java 기반 Spring API 연동
•	AWS, Cloudflare 같은 클라우드와 관련된 비용 최적화 경험</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="e-데이터-모니터링-및-오류-추적">E. 데이터 모니터링 및 오류 추적<a href="https://owonie.github.io/blog/20241113#e-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EC%98%A4%EB%A5%98-%EC%B6%94%EC%A0%81" class="hash-link" aria-label="E. 데이터 모니터링 및 오류 추적에 대한 직접 링크" title="E. 데이터 모니터링 및 오류 추적에 대한 직접 링크">​</a></h4>
<p>•	에러 및 성능 관리:
•	Sentry를 이용한 에러 추적, 성능 관리 및 분석 도구(Google Analytics, Amplitude, Mixpanel) 경험</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="f-오픈소스-및-창업-마인드">F. 오픈소스 및 창업 마인드<a href="https://owonie.github.io/blog/20241113#f-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EB%B0%8F-%EC%B0%BD%EC%97%85-%EB%A7%88%EC%9D%B8%EB%93%9C" class="hash-link" aria-label="F. 오픈소스 및 창업 마인드에 대한 직접 링크" title="F. 오픈소스 및 창업 마인드에 대한 직접 링크">​</a></h4>
<p>•	오픈소스 활동 및 Full-stack Engineering 관심
•	SaaS 제품 창업 경험이나 목표</p>]]></content>
        <author>
            <name>Dowon Choi</name>
            <uri>https://github.com/Owonie</uri>
        </author>
        <category label="JD" term="JD"/>
        <category label="풀스택" term="풀스택"/>
        <category label="기술" term="기술"/>
        <category label="커리어" term="커리어"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>https://owonie.github.io/blog/welcome</id>
        <link href="https://owonie.github.io/blog/welcome"/>
        <updated>2021-08-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docusaurus blogging features are powered by the blog plugin.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://docusaurus.io/docs/blog" target="_blank" rel="noopener noreferrer">Docusaurus blogging features</a> are powered by the <a href="https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog" target="_blank" rel="noopener noreferrer">blog plugin</a>.</p>
<p>Here are a few tips you might find useful.</p>
<p>Simply add Markdown files (or folders) to the <code>blog</code> directory.</p>
<p>Regular blog authors can be added to <code>authors.yml</code>.</p>
<p>The blog post date can be extracted from filenames, such as:</p>
<ul>
<li><code>2019-05-30-welcome.md</code></li>
<li><code>2019-05-30-welcome/index.md</code></li>
</ul>
<p>A blog post folder can be convenient to co-locate blog post images:</p>
<p><img decoding="async" loading="lazy" alt="Docusaurus Plushie" src="https://owonie.github.io/assets/images/docusaurus-plushie-banner-a60f7593abca1e3eef26a9afa244e4fb.jpeg" width="1500" height="500" class="img_ev3q"></p>
<p>The blog supports tags as well!</p>
<p><strong>And if you don't want a blog</strong>: just delete this directory, and use <code>blog: false</code> in your Docusaurus config.</p>]]></content>
        <author>
            <name>Dowon Choi</name>
            <uri>https://github.com/Owonie</uri>
        </author>
        <category label="Facebook" term="Facebook"/>
        <category label="Hello" term="Hello"/>
        <category label="Docusaurus" term="Docusaurus"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MDX Blog Post]]></title>
        <id>https://owonie.github.io/blog/mdx-blog-post</id>
        <link href="https://owonie.github.io/blog/mdx-blog-post"/>
        <updated>2021-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Blog posts support Docusaurus Markdown features, such as MDX.]]></summary>
        <content type="html"><![CDATA[<p>Blog posts support <a href="https://docusaurus.io/docs/markdown-features" target="_blank" rel="noopener noreferrer">Docusaurus Markdown features</a>, such as <a href="https://mdxjs.com/" target="_blank" rel="noopener noreferrer">MDX</a>.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>팁</div><div class="admonitionContent_BuS1"><p>Use the power of React to create interactive blog posts.</p></div></div>
<!-- -->
<p>For example, use JSX to create an interactive button:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">button onClick</span><span class="token operator" style="color:#393A34">=</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">alert</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'button clicked!'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">}</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token maybe-class-name">Click</span><span class="token plain"> me</span><span class="token operator" style="color:#393A34">!</span><span class="token operator" style="color:#393A34">&lt;</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">button</span><span class="token operator" style="color:#393A34">&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<button>Click me!</button>]]></content>
        <author>
            <name>Dowon Choi</name>
            <uri>https://github.com/Owonie</uri>
        </author>
        <category label="Docusaurus" term="Docusaurus"/>
    </entry>
</feed>